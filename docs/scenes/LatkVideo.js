import{aj as e,a2 as t,O as n,B as i,y as o,V as s,ak as r,N as a,al as h,S as v,P as l}from"../vendor.js";class p{constructor(n){var{artifact:i}=n;this.config=e(i,{pos:{x:-1.9,y:-1.25,z:-3.5},scaler:3.3,lightColor:8421504}),this.light=new t(this.config.lightColor)}beforeLoadModel(e){var{engine:t,preload:p}=e;this.model=new n,this.model.position.set(0,0,0),p.assets.gltf&&(p.assets.gltf.scene.position.set(0,1,0),this.model.add(p.assets.gltf.scene),this.light.color.setRGB(.25,1,1),this.model.add(this.light)),this.renderer=t.renderer,this.camera=t.camera,this.scene=t.scene,this.buffer=new i;var c=new o(1,256,256),u=new s(t.videoElement);u.format=r,u.minFilter=a,u.magFilter=h,u.generateMipmaps=!1;var g=new v({uniforms:{tex:{type:"t",value:u}},transparent:!1,vertexShader:"\nvarying vec2 vUv;\nvarying float visibility;\nuniform sampler2D tex;\n\n// * * * * * * * * * * * * * * * * *\nconst float satThresh = 0.5;    // orig 0.5 or 0.85\nconst float brightThresh = 0.5;   // orig 0.5 or 0.85 or 0.9\nconst float epsilon = 1.0e-10; // orig 1.0e-10 or 0.0000000001 or orig 0.03\nconst float visibilityThreshold = 0.99;\n// * * * * * * * * * * * * * * * * *\n\nconst float meshDensityVal = 2048.0;\nconst vec2 meshDensity = vec2(meshDensityVal, meshDensityVal);\nconst int numNeighbors = 4; // orig 8\nconst int numDudNeighborsThreshold = int(float(numNeighbors) * 0.75);\n\nfloat rgbToHue(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n\n    vec3 result = vec3(abs(q.z + (q.w - q.y) / (6.0 * d + epsilon)), d / (q.x + epsilon), q.x);\n\n    return result.g > satThresh && result.b > brightThresh ? result.r : 0.0;\n}\n\nfloat depthForPoint(vec2 uv) {\n  return rgbToHue(texture2D(tex, uv).rgb);\n}\n\nfloat calculateVisibility(float depth, vec2 uv) {\n  float visibility = 1.0;\n    vec2 textureStep = 1.0 / meshDensity;\n    float neighborDepths[numNeighbors];\n  neighborDepths[0] = depthForPoint(uv + vec2(0.0,  textureStep.y));\n  neighborDepths[1] = depthForPoint(uv + vec2(textureStep.x, 0.0));\n  neighborDepths[2] = depthForPoint(uv + vec2(0.0, -textureStep.y));\n  neighborDepths[3] = depthForPoint(uv + vec2(-textureStep.x, 0.0));\n  //neighborDepths[4] = depthForPoint(uv + vec2(-textureStep.x, -textureStep.y));\n  //neighborDepths[5] = depthForPoint(uv + vec2(textureStep.x,  textureStep.y));\n  //neighborDepths[6] = depthForPoint(uv + vec2(textureStep.x, -textureStep.y));\n  //neighborDepths[7] = depthForPoint(uv + vec2(-textureStep.x,  textureStep.y));\n\n    // Search neighbor verts in order to see if we are near an edge.\n    // If so, clamp to the surface closest to us.\n    int numDudNeighbors = 0;\n    if (depth < epsilon || (1.0 - depth) < epsilon) {\n        float nearestDepth = 1.0;\n        for (int i=0; i<numNeighbors; i++) {\n            float depthNeighbor = neighborDepths[i];\n            if (depthNeighbor >= epsilon && (1.0 - depthNeighbor) > epsilon) {\n                if (depthNeighbor < nearestDepth) {\n                    nearestDepth = depthNeighbor;\n                }\n            } else {\n                numDudNeighbors++;\n            }\n        }\n\n        depth = nearestDepth;\n        visibility = 0.8;\n\n        // Blob filter\n        if (numDudNeighbors > numDudNeighborsThreshold) {\n            visibility = 0.0;\n        }\n    }\n\n    // Internal edge filter\n    float maxDisparity = 0.0;\n\n    for (int i=0; i<numNeighbors; i++) {\n        float depthNeighbor = neighborDepths[i];\n        if (depthNeighbor >= epsilon && (1.0 - depthNeighbor) > epsilon) {\n            maxDisparity = max(maxDisparity, abs(depth - depthNeighbor));\n        }\n    }\n\n    visibility *= 1.0 - maxDisparity;\n\n    return visibility;\n}\n\nvoid main() {\n    gl_PointSize = 6.0;\n\n    vUv = uv;\n    vec2 uvX = vec2(0.5 + uv.x * 0.5, 0.5 + uv.y * 0.5);\n    vec2 uvY = vec2(0.5 + uv.x * 0.5, uv.y * 0.5);\n    vec2 uvZ = vec2(uv.x * 0.5, uv.y * 0.5);\n\n    float posX = depthForPoint(uvX);\n    float posY = depthForPoint(uvY);\n    float posZ = depthForPoint(uvZ);\n\n  float visX = calculateVisibility(posX, uvX);\n  float visY = calculateVisibility(posY, uvY);\n  float visZ = calculateVisibility(posZ, uvZ);\n  visibility = visX < visibilityThreshold || visY < visibilityThreshold || visZ < visibilityThreshold ? 0.0 : 1.0;\n\n    vec3 newPosition = vec3(posX, posY, posZ);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}",fragmentShader:"\nvarying vec2 vUv;\nvarying float visibility;\nuniform sampler2D tex;\n\nvec3 saturation(vec3 rgb, float adjustment) {\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nvoid main() {\n    vec2 uvRgb = vec2(vUv.x * 0.5, 0.5 + vUv.y * 0.5);\n    vec4 col = texture2D(tex, uvRgb);\n\n    if (visibility < 0.9) discard;\n\n    gl_FragColor = vec4(saturation(col.xyz, 1.2), 0.25);\n}"}),d=new l(c,g),{scaler:b}=this.config;d.scale.set(b,b,2*b);var{pos:f}=this.config;d.position.set(f.x,f.y,f.z),this.model.add(d)}tick(){this.light.intensity=Math.random()+1}}export{p as default};

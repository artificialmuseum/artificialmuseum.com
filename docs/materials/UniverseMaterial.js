import{S as n,K as e,a8 as a}from"../vendor.js";class t extends n{constructor(n){super();var{config:t}=n;this.config=e(t,{resolution:{x:512,y:512},speed:1,startTime:0}),this.setValues({transparent:!0,side:a,uniforms:{uTime:{value:this.config.startTime,type:"f"},uRes:{value:this.config.resolution,type:"f2"}},fragmentShader:"\n#ifdef GL_ES\n  precision mediump float;\n#endif\n\nuniform float uTime;\nuniform vec2 uRes;\n\n#define iterations 14\n#define formuparam 0.530\n#define uTime cos(uTime*.2)\n#define volsteps 18\n#define stepsize 0.2\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.00001\n\n#define brightness 0.00045\n#define darkmatter 0.400\n#define distfading 0.760\n#define saturation 0.800\n\nvoid main(void) {\n  //get coords and direction\n  vec2 uv = gl_FragCoord.xy / uRes.xy;\n  uv.y *= uRes.y / uRes.x;\n  vec3 dir = vec3(uv * zoom, tan(.3) * 1000.0);\n\n  float a2 = speed+.5;\n  float a1 = 0.0;\n  mat2 rot1 = mat2(cos(a1),tan(a1),-sin(a1),cos(a1));\n  mat2 rot2 = rot1;//mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n  dir.xz *= rot1;\n  dir.xy *= rot2;\n\n  //from.x- = uTime;\n  vec3 from = vec3(0., 0., 0.);\n  from += vec3((tan(.15), .152, -2.));\n\n  from.xz *= rot1;\n  from.xy *= rot2;\n\n  //volumetric rendering\n  float s = .4;\n  float fade = .2;\n\n  vec3 v = vec3(0.8);\n  for (int r = 0; r<volsteps; r++) {\n    vec3 p = from + s * dir * .5;\n\n    // tiling fold\n    p = abs(vec3(tile) - mod(p,vec3(tile*2.)));\n\n    float pa = 0.;\n    float a = 0.;\n\n    for (int i = 0; i<iterations; i++) {\n      // the magic formula\n      p = abs(p)/dot(p,p)-formuparam*(abs(sin(uTime / 5.0)) + .6);\n\n      // absolute sum of average change\n      a += abs(length(p)-pa);\n\n      pa = length(p);\n    }\n\n    //dark matter\n    float dm = max(0., darkmatter - a * a * tan(.001));\n\n    // add contrast\n    a *=  a * a * 2.;\n\n    // dark matter, don't render near\n    if (r>3) {\n      fade *=  1.-dm;\n    }\n\n    v += fade;\n\n    // coloring based on distance\n    v += vec3(s*s, s*s*s, s*s*s*s) * a * brightness * fade;\n\n    fade *= distfading / 1.2; // distance fading\n    s += stepsize;\n  }\n\n  //color adjust\n  v = mix(vec3(length(v)), v, saturation);\n\n  gl_FragColor = vec4(v*.01, 2.);\n}\n"})}}export{t as default};
